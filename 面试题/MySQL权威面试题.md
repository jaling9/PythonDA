<b>更多面试题，干货内容，可以查看此处，从编程工具到面试要点。
全流程编程工具集&学习集 https://www.johngo689.com/2617/，欢迎留言交流！</b> 
<i>以下面试题来自网络以及自己整理，如有侵权，请及时联系删除！</i> 
 *** 
[TOC]

### 1、实践中如何优化 MySQL?
<p>最好是按照以下顺序优化:</p><ul><li>SQL语句及索引的优化</li><li>数据库表结构的优化</li><li>系统配置的优化</li><li>硬件的优化</li></ul>



### 2、优化子查询？
<ul><li>用关联查询替代。</li><li>优化GROUPBY和DISTINCT。</li><li>这两种查询据可以使用索引来优化，是最有效的优化方法。</li><li>关联查询中，使用标识列分组的效率更高。</li><li>如果不需要 ORDER BY，进行 GROUP BY 时加 ORDER BY NULL，MySQL 不会再进行文件排序。</li><li>WITH ROLLUP 超级聚合，可以挪到应用程序处理。</li></ul>



### 3、前缀索引
<h3>语法：index(field(10))</h3><p>使用字段值的前10个字符建立索引，默认是使用字段的全 部内容建立索引。</p><h3>前提</h3><p>前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。</p><h3>实操的难度</h3><p>在于前缀截取的长度。</p><p>我们可以利用 select count(*)/count(distinct left(password,prefixLen));，通过从调整 prefixLen 的值(从 1 自增)查看不同前缀长度的一个平均匹配度，接近 1 时就可 以了(表示一个密码的前 prefixLen 个字符几乎能确定唯一一条记录)。</p>



### 4、MySQL 5.6 和 MySQL 5.7 对索引做了哪些优化?
<p>MySQL5.6引入了索引下推优化，默认是开启的。</p><p>例子:user表中(a,b,c)构成一个索引。</p><p>select * from user where a='23' and b like '%eqw%' and c like 'dasd'。</p><h3>解释</h3><p>如果没有索引下推原则，则 MySQL 会通过 a='23' 先查询出一个对应的数据。然后返回到 MySQL 服务端。MySQL 服务端再基于两个 like 模糊查询来校验 and 查询出的数据是否符合条件。这个过程就设计到回表操作。</p><p>如果使用了索引下推技术，则MySQL会首先返回返回条件a='23'的数据的索引，然后根据模糊查询的条件来校验索引行数据是否符合条件，如果符合条件，则直接根据 索引来定位对应的数据，如果不符合直接 reject 掉。因此，有了索引下推优化，可以在有 like 条件的情况下，减少回表的次数。</p>



### 5、MySQL 有关权限的表有哪几个呢?
<p>MySQL 服务器通过权限表来控制用户对数据库的访问，权限表存放在 MySQL 数据库里，由 MySQL_install_db 脚本初始化。这些权限表分别 user，db，table_priv， columns_priv 和 host。</p><h3>user权限表</h3><p>记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</p><h3>db 权限表</h3><p>记录各个帐号在各个数据库上的操作权限。</p><h3>table_priv 权限表</h3><p>记录数据表级的操作权限。</p><h3>columns_priv 权限表</h3><p>记录数据列级的操作权限。</p><h3>host 权限表</h3><p>配合 db 权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受 GRANT 和 REVOKE 语句的影响。</p>



### 6、MySQL 中都有哪些触发器?
<p>MySQL 数据库中有六种触发器:</p><ul><li>Before Insert</li><li>After Insert</li><li>Before Update</li><li>After Update</li><li>Before Delete</li><li>After Delete</li></ul>



### 7、大表怎么优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？
<p>当 MySQL 单表记录数过大时，数据库的 CRUD 性能会明显下降，一些常见的优化措施如下:</p><p>限定数据的范围: 务必禁止不带任何限制数据范围条件的查询语句。比如:我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内;</p><p>读/写分离: 经典的数据库拆分方案，主库负责写，从库负责读;</p><p>缓存: 使用 MySQL 的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存;</p><p>还有就是通过分库分表的方式进行优化。主要有垂直分区、垂直分表、水平分区、水平分表。</p><p>&nbsp;</p><h3>垂直分区</h3><p>1、 根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p><p>2、 简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 如下图所示，这样来说大家应该就更容易理解了。</p><p><img src="https://www.johngo689.com/wp-content/uploads/member/avatars/my1-1.jpg" alt="my1-1" /></p><h4>垂直拆分的优点</h4><p>可以使得行数据变小，在查询时减少读取的 Block 数，减少 I/O 次数。此外，垂直分区可 以简化表的结构，易于维护。</p><h4>垂直拆分的缺点</h4><p>主键会出现冗余，需要管理冗余列，并会引起 Join 操作，可以通过在应用层进行 Join 来解决。此外，垂直分区会让事务变得更加复杂。</p><p>&nbsp;</p><h3>垂直分表</h3><p>把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中</p><p><img src="https://www.johngo689.com/wp-content/uploads/member/avatars/my2-1.jpg" alt="my2-1" /></p><h4>适用场景</h4><ul><li>如果一个表中某些列常用，另外一些列不常用</li><li>可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数</li></ul><h4>缺点</h4><ul><li>有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差</li><li>对于应用层来说，逻辑算法增加开发成本</li><li>管理冗余列，查询所有数据需要join操作</li></ul><p>&nbsp;</p><h3>水平分区</h3><ul><li>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</li><li>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子:我们可以将用户信息表拆分成多个用户 信息表，这样就可以避免单一表数据量过大对性能造成影响。</li></ul><p><img src="https://www.johngo689.com/wp-content/uploads/member/avatars/my3-1.jpg" alt="my3-1" /></p><ul><li>水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据 过大的问题，但由于表的数据还是在同一台机器上，其实对于提升 MySQL 并发能力 没有什么意义，所以 水平拆分最好分库 。</li><li>水平拆分能够支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ， 跨界点 Join 性能较差，逻辑复杂。</li></ul><p>&nbsp;</p><h3>水平分表 </h3><p>表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数。</p><p><img src="https://www.johngo689.com/wp-content/uploads/member/avatars/my4.jpg" alt="my4" /></p><h4>适用场景</h4><ul><li>表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。</li><li>需要把数据存放在多个介质上。</li></ul><h4>水平切分的缺点</h4><ul><li>给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作。</li><li>在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数。</li></ul><p>&nbsp;</p><h3>数据库分片的两种常见方案</h3><h4>客户端代理</h4><p>分片逻辑在应用端，封装在 jar 包中，通过修改或者封装 JDBC 层来实现。当当网<br />的 Sharding-JDBC 、阿里的 TDDL 是两种比较常用的实现。</p><h4>中间件代理</h4><p>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。** 我们现在谈的 Mycat** 、360 的 Atlas、网易的 DDB 等等都是这种架构的实现。</p><h3>分库分表后面临的问题</h3><h4>事务支持</h4><p>分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事 务，将付出高昂的性能代价; 如果由应用程序去协助控制，形成程序逻辑上的事务，又会 造成编程方面的负担。</p><h4>跨库 join</h4><p>只要是进行切分，跨节点 Join 的问题是不可避免的。但是良好的设计和切分却可以减少此 类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找 出关联数据的 id,根据这些 id 发起第二次请求得到关联数据。</p><h4>数据迁移，容量规划，扩容等问题</h4><p>来自淘宝综合业务平台团队，它利用对 2 的倍数取余具有向前兼容的特性(如对 4 取余得 1 的数对 2 取余也是 1)来分配数据，避免了行级别的数据迁移，但是依然需要进行表级 别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了 Sharding 扩容的难度。</p><h4>ID 问题</h4><p>一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一 方面，某个分区数据库自生成的 ID 无法保证在全局上是唯一的;另一方面，应用程序在 插入数据之前需要先获得 ID,以便进行 SQL 路由、一些常见的主键生成策略<br />UUID 使用 UUID 作主键是最简单的方案，但是缺点也是非常明显的。由于 UUID 非常的 长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询 时都存在性能问题。 Twitter 的分布式自增 ID 算法 Snowflake 在分布式系统中，需要生 成全局 UID 的场合还是比较多的，twitter 的 snowflake 解决了这种需求，实现也还是很 简单的，除去配置信息，核心代码就是毫秒级时间 41 位 机器 ID 10 位 毫秒内序列 12 位。</p><h4>跨分片的排序分页问题</h4><p>一般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通 过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会 变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序 并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示:</p><p><img src="https://www.johngo689.com/wp-content/uploads/member/avatars/my6-1.jpg" alt="my6-1" /></p>



### 8、B+ Tree 索引和 Hash 索引区别?
<ul><li>hash索引适合等值查询，但是无法进行范围查询。</li><li>hash索引没办法利用索引完成排序。</li><li>hash索引不支持多列联合索引的最左匹配规则。</li><li>如果有大量重复健值得情况下，hash索引的效率会很低，因为哈希碰撞问题。</li></ul>



### 9、数据库索引的原理，为什么要用 B+树，为什么不用二叉树？
<blockquote><p>可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找 磁盘次数，为什么不是二叉树，为什么不是平衡二叉树，为什么不是 B 树，而偏偏是 B+树呢?</p></blockquote><h3>为什么不是一般二叉树?</h3><p>如果二叉树特殊化为一个链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。</p><h3>为什么不是平衡二叉树呢?</h3><p>我们知道，在内存比在磁盘的数据，查询效率快得多。如果树这种数据结构作为索引，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，但是平 衡二叉树可是每个节点只存储一个键值和数据的，如果是 B 树，可以存储更多的节点数 据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快啦。</p><h3>为什么不是 B 树而是 B+树呢?</h3><ol><li>B+树非叶子节点上是不存储数据的，仅存储键值，而 B 树节点中不仅存储键值，也会存储数据。innodb 中页的默认大小是 16KB，如果不存储数据，那么就会存储更多的键值，相应的树的阶数(节点的子节点树)就会更大，树就会更矮更胖，如此一来我们查找 数据进行磁盘的 IO 次数有会再次减少，数据查询的效率也会更快。</li><li>B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着的。 那么 B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。</li></ol>



### 10、据库三大范式是什么？
<h3>第一范式</h3><p>每个列都不可以再拆分。</p><h3>第二范式</h3><p>在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p><h3>第三范式</h3><p>在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p><p>&nbsp;</p><p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。</p><p>事实上我们经常会为了性能而妥协数据库的设计。</p>



### 11、MySQL 存储引擎 MyISAM 与 InnoDB 区别
<h3>锁粒度方面</h3><p>由于锁粒度不同，InnoDB比MyISAM支持更高的并发;InnoDB 的锁粒度为行锁、MyISAM 的锁粒度为表锁、行锁需要对每一行进行加锁，所以锁的开销更大，但是能解决脏读和不可重复读的问题，相对来说也更容易发生死锁</p><h3>可恢复性上</h3><p>由于InnoDB是有事务日志的，所以在产生由于数据库崩溃等条件后，可以根据日志文件进行恢复。而 MyISAM 则没有事务日志。 </p><h3>查询性能上</h3><p>MylSAM要优于InnoDB因为InnoDB在查询过程中，是需要维护数据缓存，而且查询过程是先定位到行所在的数据块，然后在从数据块中 定位到要查找的行;而 MyISAM 可以直接定位到数据所在的内存地址，可以 直接找到数据。 </p><h3>表结构文件上</h3><p>MyISAM的表结构文件包括:frm(表结构定义),.MYI(索 引),.MYD(数据);而 InnoDB 的表数据文件为:ibd 和 frm(表结构定义)。</p>



### 12、MyISAM 索引与 InnoDB 索引的区别?
<ul><li>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。 </li><li>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。 </li><li>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。 </li><li>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</li></ul>



### 13、什么是索引?
<p>索引是一种特殊的文件(InnoDB 数据表上的索引是表空间的一个组成部分)，它 们包含着对数据表里所有记录的引用指针。 索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用 B 树及其变 种 B+树。</p><p>更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。</p>


